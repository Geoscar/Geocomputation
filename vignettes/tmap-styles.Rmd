---
title: "Map styles available in the tmap package"
author: "Robin Lovelace, Jakub Nowosad, Jannes Muenchow"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
      toc: true
      number_sections: true
vignette: >
  %\VignetteIndexEntry{tmap-styles}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, eval = F,
                      fig.width = 8, fig.height = 4)
```

This vignette builds on the [making maps chapter](https://geocompr.robinlovelace.net/adv-map.html) of [the Geocomputation with R book](https://geocompr.github.io/).
Its goal is to demonstrate all possible map styles available in the **tmap** package.

## Prerequisites {-}

The examples below assume the following packages are attached:

```{r}
library(spData) # example datasets
library(tmap)   # map creation
library(sf)     # spatial data reprojection
```

The `world` object containing a world map data from [Natural Earth](https://www.naturalearthdata.com/) and information about countries' names, regions, and subregions they belong to, areas, life expectancies, and populations.
This object is in geographical coordinates using the WGS84 datum, however, for mapping purposes, the Mollweide projection is a better alternative (learn more in [the modifying map projections section](https://geocompr.robinlovelace.net/reproj-geo-data.html#modifying-map-projections)).
The `st_tranform` function from the **sf** package allows for quick reprojection to the selected coordinate reference system (e.g., `"+proj=moll"` represents the Mollweide projection).

```{r}
world_moll = st_transform(world, crs = "+proj=moll")
```

# One color

Let's start with the basics.
To create a simple world map, we need to specify the data object (`world_moll`) inside the `tm_shape()` function, and the way we want to visualize it.
The **tmap** package offers several visualisation possibilities for polygons, including `tm_borders()`, `tm_fill()`, and `tm_polygons()`.
The last one draws the filled polygons with borders, where the fill color can be specified with the `col` argument:

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lightblue")
```

The output is a map of world countries, where each country is filled with a light blue color.

# Coloring of adjacent polygons

The `col` argument is very flexible, and its action depends on the value provided.
In the previous example, we provided a single color value resulting in a map with one color. 
To create a map, where adjacent polygons do not get the same color, we need to provide a keyword `"MAP_COLORS"`.

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "MAP_COLORS")
```

The default color can be changed using the `palette` argument - run the `tmaptools::palette_explorer()` function to see possible palettes' names.

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "MAP_COLORS",
              palette = "Pastel1")
```

<!-- Additionally, the number of classes can be set using the `n` argument. -->
Additionally, in this case, it is possible to use the `minimize` argument, which triggers the internal algorithm to search for a minimal number of colors for visualization.

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "MAP_COLORS",
              minimize = TRUE)
```

The new map uses five colors<!-- except for Angola (blue color)-->. 
On a side note, in theory, no more than four colors are required to color the polygons of the map so that no two adjacent polygons have the same color (learn more about the four color map theorem on [wikipedia](https://en.wikipedia.org/wiki/Four_color_theorem)).

# Categorical maps

The third use of the `col` argument is by providing the variable (column) name.
In this case, the map will represent the given variable.
By default, **tmap** behaves differently depending on the input variable type.
For example, it will create a categorical map when the provided variable contains characters or factors.^[The `tm_polygons(col = "subregion", style = "cat")` code will be used automatically in this case.]

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "subregion")+
  tm_layout(legend.outside = TRUE) 
```

# Discrete maps

<!-- Discrete maps  -->

## Fixed

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp", 
              style = "fixed",
              breaks = c(50, 60, 70, 80, 90),
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) 
```

## Pretty

The `"pretty"` style rounds breaks into whole numbers where possible and spaces them evenly.

`tm_polygons(col = "lifeExp", style = "pretty")`

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp",
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) 
```

<!-- n is approximation -->

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp",
              legend.hist = TRUE,
              n = 4) +
  tm_layout(legend.outside = TRUE) 
```

<!-- https://r-spatial.github.io/classInt/index.html -->


## Breaks based on the centred and scaled variable

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp", 
              style = "sd",
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE)
```


## Jenks natural breaks 

The `"jenks"` style identifies groups of similar values in the data and maximizes the differences between categories.

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp",
              style = "jenks",
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) 
```

## Fisher-Jenks algorithm

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp",
              style = "fisher",
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) 
```

## Bagged clustering

```{r, message=FALSE}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp",
              style = "bclust",
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) 
```

## Hierarchical clustering

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp",
              style = "hclust",
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) 
```

## k-means clustering

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp", 
              style = "kmeans",
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) 
```

## Quantile breaks

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp", 
              style = "quantile",
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) 
```

## Equal breaks

The `"equal"` style divides input values into bins of equal range, and is appropriate for variables with a uniform distribution (not recommended for variables with a skewed distribution as the resulting map may end-up having little color diversity).

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp", 
              style = "equal",
              legend.hist = TRUE) +
  tm_layout(legend.outside = TRUE) 
```


## Continuous

The `"cont"` style presents a large number of colors over continuous color field.

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp",
              style = "cont") +
  tm_layout(legend.outside = TRUE) 
```

The `"order"` style also presents a large number of colors over continuous color field. 
However, this style is suited to visualize skewed distributions.

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "lifeExp",
              style = "order") +
  tm_layout(legend.outside = TRUE) 
```

## Logarithmic scale

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "pop") +
  tm_layout(legend.outside = TRUE) 
```

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "pop", 
              style = "cont") +
  tm_layout(legend.outside = TRUE) 
```

The `"log10_pretty"` style 

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "pop", 
              style = "log10_pretty") +
  tm_layout(legend.outside = TRUE) 
```

The `"log10"` style 

```{r}
tm_shape(world_moll) +
  tm_polygons(col = "pop", 
              style = "log10") +
  tm_layout(legend.outside = TRUE) 
```
